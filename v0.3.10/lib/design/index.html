<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Design · JuDoc.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>JuDoc.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../../man/workflow/">Workflow</a></li><li><a class="toctext" href="../../man/syntax/">Syntax</a></li><li><a class="toctext" href="../../man/templating/">Templating</a></li><li><a class="toctext" href="../../man/themes/">Themes</a></li><li><a class="toctext" href="../../man/contrib/">Contributing</a></li><li><a class="toctext" href="../../man/troubleshooting/">Troubleshooting</a></li></ul></li><li><span class="toctext">Library</span><ul><li class="current"><a class="toctext" href>Design</a><ul class="internal"><li><a class="toctext" href="#Big-Picture-1">Big Picture</a></li><li><a class="toctext" href="#Parsing-1">Parsing</a></li><li><a class="toctext" href="#Conversion-1">Conversion</a></li></ul></li><li><a class="toctext" href="../public/">Public</a></li><li><a class="toctext" href="../internals/">Internals</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Library</li><li><a href>Design</a></li></ul><a class="edit-page" href="https://github.com/tlienart/JuDoc.jl/blob/master/docs/src/lib/design.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Design</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Design-1" href="#Design-1">Design</a></h1><p>This page aims to shed some light on how JuDoc works and how the code is structured which could be of interest for anyone willing to contribute to the codebase.</p><h2><a class="nav-anchor" id="Big-Picture-1" href="#Big-Picture-1">Big Picture</a></h2><h3><a class="nav-anchor" id="Compilation-1" href="#Compilation-1">Compilation</a></h3><p>The overarching sequence for the initial <em>full pass</em> is:</p><ol><li>retrieve the paths to files that should be processed (<a href="../internals/#JuDoc.jd_setup"><code>JuDoc.jd_setup</code></a>),</li><li>process all files (<a href="../internals/#JuDoc.jd_fullpass"><code>JuDoc.jd_fullpass</code></a>)<ul><li>if it&#39;s a markdown file convert it to HTML (see below),</li><li>place generated file in appropriate locations.</li></ul></li></ol><p>In general the user will use <code>serve()</code> which triggers a full pass followed by a loop that re-processes files individually upon modifications (<a href="../internals/#JuDoc.jd_loop"><code>JuDoc.jd_loop</code></a>).</p><h3><a class="nav-anchor" id="File-processing-1" href="#File-processing-1">File processing</a></h3><p>The file processing is controlled by the function <a href="../internals/#JuDoc.process_file"><code>JuDoc.process_file</code></a> which, itself, is a thin wrapper around the function <a href="../internals/#JuDoc.process_file_err"><code>JuDoc.process_file_err</code></a> (the first one processes any errors that may be generated during the processing of files). There are three types of files:</p><ul><li>markdown files (<code>.md</code>) which are parsed and converted into HTML,</li><li>HTML files (<code>.html</code>) which are parsed and re-generated after solving any templating commands they may contain,</li><li>other files which are just copied over to the relevant location.</li></ul><p>In the case of markdown files, the function <a href="../internals/#JuDoc.write_page"><code>JuDoc.write_page</code></a> is called and is formed of 3 key stages:</p><ol><li>parsing of the markdown (<a href="../internals/#JuDoc.convert_md"><code>JuDoc.convert_md</code></a>)</li><li>conversion to HTML and assembly of different blocks into one page (<a href="../internals/#JuDoc.convert_html"><code>JuDoc.convert_html</code></a> and <a href="../internals/#JuDoc.build_page"><code>JuDoc.build_page</code></a>),</li><li>writing the HTML in the appropriate location, possibly after pre-rendering javascript (<a href="../internals/#JuDoc.js_prerender_katex"><code>JuDoc.js_prerender_katex</code></a>, <a href="../internals/#JuDoc.js_prerender_highlight"><code>JuDoc.js_prerender_highlight</code></a>).</li></ol><h2><a class="nav-anchor" id="Parsing-1" href="#Parsing-1">Parsing</a></h2><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>If you wonder why I didn&#39;t just use a &quot;standard parser&quot;, one of my personal goal was to try to build a parser from scratch to get an idea of how one would work. I don&#39;t doubt better can be done though I doubt it&#39;s a serious bottleneck at the moment.</p></div></div><p>At the very basic level, the parser reads the content from left to right and tries to find &quot;blocks&quot; that should be processed in a specific way. Once blocks have been found, each block gets processed in turn following the appropriate order in which they appear. Finally, they are re-assembled after processing.</p><p>The overarching block type is the <a href="../internals/#JuDoc.AbstractBlock"><code>JuDoc.AbstractBlock</code></a> with as key sub-types <code>Token</code> and <code>OCBlock</code>:</p><ul><li><a href="../internals/#JuDoc.Token"><code>JuDoc.Token</code></a>: these correspond to the idea of a <em>specific sequence of characters</em> which typically will denote the <em>start</em> or the <em>end</em> of an environment. The type contains a substring corresponding to the matched token and a name indicating what the token is.</li></ul><pre><code class="language-julia-repl">julia&gt; s = raw&quot;Hello, $x=5$ end&quot;;
julia&gt; t = JuDoc.find_tokens(s, JuDoc.MD_TOKENS, JuDoc.MD_1C_TOKENS)
2-element Array{JuDoc.Token,1}:
 JuDoc.Token(:MATH_A, &quot;\$&quot;)
 JuDoc.Token(:MATH_A, &quot;\$&quot;)

julia&gt; JuDoc.from(t[1])
8
julia&gt; JuDoc.from(t[1])
12</code></pre><ul><li><a href="../internals/#JuDoc.OCBlock"><code>JuDoc.OCBlock</code></a>: these correspond to the idea of an <em>environment</em> delimited by an opening and a closing token. The type contains a substring corresponding to the full block, a name indicating what the environment is and a pair of opening and closing tokens (whence the name &quot;O/C&quot;).</li></ul><pre><code class="language-julia-repl">julia&gt; ocb, _ = JuDoc.find_all_ocblocks(t, JuDoc.MD_OCB_ALL);
julia&gt; ocb
1-element Array{JuDoc.OCBlock,1}:
 JuDoc.OCBlock(:MATH_A, JuDoc.Token(:MATH_A, &quot;\$&quot;) =&gt; JuDoc.Token(:MATH_A, &quot;\$&quot;), &quot;\$x=5\$&quot;, false)

julia&gt; JuDoc.from(ocb[1])
8

julia&gt; JuDoc.to(ocb[2])
12</code></pre><h3><a class="nav-anchor" id="Finding-Tokens-1" href="#Finding-Tokens-1">Finding Tokens</a></h3><p>The function <a href="../internals/#JuDoc.find_tokens"><code>JuDoc.find_tokens</code></a> takes content, reads it from left to right and returns a list of <code>Token</code>s. It takes a string, and two &quot;token dictionaries&quot;. The first one describes tokens that span <em>multiple characters</em> while the second one correspond to tokens that span <em>a single character</em>.</p><p>Single character tokens are tokens that are exclusively defined by a single character. These characters <strong>cannot</strong> be part of multi-chars tokens. For instance, <a href="../internals/#JuDoc.MD_1C_TOKENS"><code>JuDoc.MD_1C_TOKENS</code></a> corresponds to single-char tokens in markdown with entries such as:</p><pre><code class="language-julia">&#39;{&#39;  =&gt; :LXB_OPEN,</code></pre><p>The key of these entries is a <code>Char</code> and as soon as the function sees that character while it reads the content, a Token is formed with the corresponding name (here <code>:LXB_OPEN</code> which stands for <em>latex-brace-open</em>).</p><p>As for multi-char tokens, for instance, <a href="../internals/#JuDoc.MD_TOKENS"><code>JuDoc.MD_TOKENS</code></a>, entries look like:</p><pre><code class="language-julia">&#39;&lt;&#39; =&gt; [ isexactly(&quot;&lt;!--&quot;) =&gt; :COMMENT_OPEN ],</code></pre><p>The key of these entries is also of type <code>Char</code> (the first character of such a token) followed by a vector of <a href="../internals/#JuDoc.TokenFinder"><code>JuDoc.TokenFinder</code></a> which essentially is a pair where the first value indicates how to match the token and the second one what name to associate to it if there is a match. Since multiple tokens can start with the same character, there is a vector of &quot;rules&quot;. Note that order in the vector matters: the first match wins.</p><p>In the case above, if the function sees a <code>&lt;</code> character while reading the content, it will look ahead and try to match exactly <code>&lt;!--</code>. If there is a match, then a Token is formed with name <code>:COMMENT_OPEN</code>.</p><p>Another look-ahead rule is <code>incrlook</code> which matches a variable number of characters that respect a given condition. For instance, let&#39;s consider markdown tokens that start with <code>@</code>:</p><pre><code class="language-julia">&#39;@&#39; =&gt; [
     isexactly(&quot;@def&quot;, [&#39; &#39;])  =&gt; :MD_DEF_OPEN,
     isexactly(&quot;@@&quot;, SPACER)   =&gt; :DIV_CLOSE,
     incrlook((i, c) -&gt; ifelse(i==1, c==&#39;@&#39;, α(c, (&#39;-&#39;,)))) =&gt; :DIV_OPEN ],</code></pre><p>The vector of <code>TokenFinder</code> contains three rules:</p><ol><li>try to match exactly <code>@def</code> followed by a space in which case a <code>:MD_DEF_OPEN</code> token is created,</li><li>try to match exactly <code>@@</code> followed by any space character (e.g. a space or a line return) in which case a <code>:DIV_CLOSE</code> token is created,</li><li>try to match <code>@@</code> followed by a number of letters or dashes.</li></ol><p>For the last case, note the function <code>(i, c) -&gt; ifelse(...)</code> which takes a character index <code>i</code> and a character <code>c</code> starting at the first character after the initial matching character (here the initial matching character is an <code>@</code> so the first character after that is also an <code>@</code>). So the function checks that the first character after the matching <code>@</code> is also an <code>@</code> and subsequently accepts any character that is either a letter or a <code>-</code>.</p><pre><code class="language-julia-repl">julia&gt; s = raw&quot;Hello @@d-name ... @@ etc&quot;;
julia&gt; JuDoc.find_tokens(s, JuDoc.MD_TOKENS, JuDoc.MD_1C_TOKENS)
2-element Array{JuDoc.Token,1}:
 JuDoc.Token(:DIV_OPEN, &quot;@@d-name&quot;)
 JuDoc.Token(:DIV_CLOSE, &quot;@@&quot;)
</code></pre><h3><a class="nav-anchor" id="Finding-OCBlocks-1" href="#Finding-OCBlocks-1">Finding OCBlocks</a></h3><p><code>OCBlocks</code> are simply defined by a name, an opening and a closing token and an indicator of whether there may be nested blocks or not. The function <a href="../internals/#JuDoc.find_all_ocblocks"><code>JuDoc.find_all_ocblocks</code></a> takes a list of tokens and tries to match them corresponding to pre-defined rules.</p><p>For instance, consider <code>JD.MD_OCB</code> which describes non-math ocblocks in markdown; it contains entries like:</p><pre><code class="language-julia">:COMMENT =&gt; ((:COMMENT_OPEN =&gt; :COMMENT_CLOSE), false),</code></pre><p>indicating that a <code>:COMMENT</code> ocblock starts at a <code>:COMMENT_OPEN</code> token (a <code>&lt;!--</code>) and ends at the next <code>:COMMENT_CLOSE</code> (a <code>--&gt;</code>) with no nesting.</p><p>When nesting is allowed (for instance div blocks can be nested) then the function <code>find_all_ocblocks</code> keeps track of the number of opening and closing tokens and returns the outer-most block (which will be decomposed further at a later stage).</p><pre><code class="language-julia-repl">julia&gt; s = raw&quot;Hello @@d-name-a ... @@d-name-b @@ ... @@ etc&quot;;
julia&gt; t = JuDoc.find_tokens(s, JuDoc.MD_TOKENS, JuDoc.MD_1C_TOKENS);
julia&gt; ocb, _ = JuDoc.find_all_ocblocks(t, JuDoc.MD_OCB);
julia&gt; length(ocb)
1

julia&gt; ocb[1].name
:DIV

julia&gt; ocb[1].ss
&quot;@@d-name-a ... @@d-name-b @@ ... @@&quot;
</code></pre><p>When a token has been snapped up in a ocblock, it is marked as inactive so that it doesn&#39;t get re-processed.</p><h3><a class="nav-anchor" id="LaTeX-blocks-1" href="#LaTeX-blocks-1">LaTeX blocks</a></h3><p>When parsing a markdown file, after finding tokens and ocblocks, JuDoc tries to find <a href="../internals/#JuDoc.LxDef"><code>JuDoc.LxDef</code></a> and <a href="../internals/#JuDoc.LxCom"><code>JuDoc.LxCom</code></a> blocks (also <code>AbstractBlock</code>).</p><p>The first one corresponds to LaTeX <em>definitions</em> of the form <code>\newcommand{\name}[narg]{def}</code> while the second one corresponds to LaTeX <em>commands</em> such as <code>\foo</code> or <code>\foo{bar}</code> or <code>\foo{bar}{baz}</code> etc.</p><p>The function <a href="../internals/#JuDoc.find_md_lxdefs"><code>JuDoc.find_md_lxdefs</code></a> takes a vector of active tokens and a ocblocks and finds sequences that match the format of a newcommand. Its counterpart, <a href="../internals/#JuDoc.find_md_lxcoms"><code>JuDoc.find_md_lxcoms</code></a> takes a vector of active tokens and definitions and ocblocks and finds sequences that match the format of a command.</p><pre><code class="language-julia-repl">julia&gt; s = raw&quot;a \newcommand{\foo}[1]{_blah #1_} and \foo{hello} done.&quot;;
julia&gt; t = JuDoc.find_tokens(s, JuDoc.MD_TOKENS, JuDoc.MD_1C_TOKENS);
julia&gt; ocb, t = JuDoc.find_all_ocblocks(t, JuDoc.MD_OCB);
julia&gt; lxd, t, braces, blocks = JuDoc.find_md_lxdefs(t, ocb);
julia&gt; lxd[1]
JuDoc.LxDef(&quot;\\foo&quot;, 1, &quot;_blah #1_&quot;, 3, 33)

julia&gt; lxc, t = JuDoc.find_md_lxcoms(t, lxd, braces);
julia&gt; lxc[1]
JuDoc.LxCom(
   &quot;\\foo{hello}&quot;,
   Base.RefArray{...}(...),
   JuDoc.OCBlock[JuDoc.OCBlock(:LXB, JuDoc.Token(:LXB_OPEN, &quot;{&quot;) =&gt; JuDoc.Token(:LXB_CLOSE, &quot;}&quot;),
   &quot;{hello}&quot;, true)])
</code></pre><p>In the <code>LxCom</code>, the output was truncated for readability, the second field is a reference to the appropriate LaTeX definition of the command while the final field is a vector formed of ocblocks which correspond to each of the arguments (here only a single one: <code>{hello}</code>).</p><h3><a class="nav-anchor" id="HTML-blocks-1" href="#HTML-blocks-1">HTML blocks</a></h3><p>When parsing a HTML file, JuDoc also tries first to find tokens (see <a href="../internals/#JuDoc.HTML_TOKENS"><code>JuDoc.HTML_TOKENS</code></a>) and ocblocks (see <a href="../internals/#JuDoc.HTML_OCB"><code>JuDoc.HTML_OCB</code></a>). In particular, it will find ocblocks of the form <code>{{ ... }}</code> (&quot;HTML blocks&quot;). Subsequently, JuDoc will try to <em>qualify</em> those HTML blocks and form a specific block such as a <code>HIf</code> or a <code>HElse</code> block (see <a href="../internals/#JuDoc.qualify_html_hblocks"><code>JuDoc.qualify_html_hblocks</code></a>):</p><table><tr><th style="text-align: left">Form</th><th style="text-align: left">Name</th></tr><tr><td style="text-align: left"><code>{{if var}}</code></td><td style="text-align: left"><code>HIf</code></td></tr><tr><td style="text-align: left"><code>{{elseif var}}</code></td><td style="text-align: left"><code>HElseIf</code></td></tr><tr><td style="text-align: left"><code>{{else}}</code></td><td style="text-align: left"><code>HElse</code></td></tr><tr><td style="text-align: left"><code>{{end}}</code></td><td style="text-align: left"><code>HEnd</code></td></tr><tr><td style="text-align: left"><code>{{is[not]def var}}</code></td><td style="text-align: left"><code>HIs[Not]Def</code></td></tr><tr><td style="text-align: left"><code>{{is[not]page path}}</code></td><td style="text-align: left"><code>HIs[Not]Page</code></td></tr></table><p>These blocks can then be assembled in larger blocks such as <code>HCond</code> (corresponding to an if-elseif-else-end), see <a href="lib/@ref"><code>JuDoc.find_html_cblocks</code></a>, <a href="lib/@ref"><code>JuDoc.JuDoc.find_html_cdblocks</code></a> and <a href="lib/@ref"><code>JuDoc.JuDoc.find_html_cpblocks</code></a>.</p><h2><a class="nav-anchor" id="Conversion-1" href="#Conversion-1">Conversion</a></h2><h3><a class="nav-anchor" id="Markdown-conversion-1" href="#Markdown-conversion-1">Markdown conversion</a></h3><p>The core function corresponding to the conversion of a markdown document is, as mentioned before, <a href="../internals/#JuDoc.convert_md"><code>JuDoc.convert_md</code></a>. The first part corresponds to the parsing discussed above to find:</p><ol><li>tokens</li><li>open/close blocks</li><li>LaTeX-like definitions</li><li>LaTeX-like commands</li><li>Markdown definitions (e.g. <code>@def x = 5</code>)</li></ol><p>This parsing step creates a number of <em>blocks</em> which each have to be processed in turn. The function <a href="../internals/#JuDoc.form_inter_md"><code>JuDoc.form_inter_md</code></a> takes the vector of all blocks and latex definitions and forms an intermediate markdown where places where an insertion must occur are marked with <code>##JDINSERT##</code>. This intermediate markdown is then fed to the function <a href="../internals/#JuDoc.md2html"><code>JuDoc.md2html</code></a> which wraps around Julia&#39;s Markdown to HTML.</p><p>Finally the function <a href="../internals/#JuDoc.convert_inter_html"><code>JuDoc.convert_inter_html</code></a> takes the partial markdown and inserts the appropriately processed blocks where the <code>##JDINSERT##</code> are. The function <a href="../internals/#JuDoc.convert_block"><code>JuDoc.convert_block</code></a> takes care of how blocks are converted before insertion (for instance how a math block should be properly fenced).</p><h3><a class="nav-anchor" id="HTML-conversion-1" href="#HTML-conversion-1">HTML conversion</a></h3><p>The core function corresponding to the conversion of a html document is, as mentioned before, <a href="../internals/#JuDoc.convert_html"><code>JuDoc.convert_html</code></a>. The first part corresponds to the parsing discussed above to find:</p><ol><li>tokens</li><li>open/close blocks</li><li>conditional blocks (<code>if ... elseif ... else ... end</code>)</li><li>conditional def blocks (<code>isdef ... end</code>)</li><li>conditional page blocks (<code>ifpage ... end</code>)</li></ol><p>The final HTML page is written by sequentially writing what&#39;s between the blocks and then replacing the blocks by the appropriate content using the function <a href="lib/@ref"><code>JuDoc.convert_hblock</code></a>.</p><footer><hr/><a class="previous" href="../../man/troubleshooting/"><span class="direction">Previous</span><span class="title">Troubleshooting</span></a><a class="next" href="../public/"><span class="direction">Next</span><span class="title">Public</span></a></footer></article></body></html>
